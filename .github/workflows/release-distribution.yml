name: Create Release Distribution

on:
  release:
    types: [published]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  quick-checks:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Install BATS
        run: |
          sudo apt-get update || exit 1
          sudo apt-get install -y bats || exit 1
          bats --version || exit 1

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run unit tests
        run: bats --recursive tests/unit/ || exit 1

  full-tests:
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 30
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}

      - name: Install BATS
        run: |
          if [ "${{ runner.os }}" == "Linux" ]; then
            sudo apt-get update || exit 1
            sudo apt-get install -y bats || exit 1
            bats --version || exit 1
          elif [ "${{ runner.os }}" == "macOS" ]; then
            brew install bats-core || exit 1
            bats --version || exit 1
          fi

      - name: Configure Git
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"

      - name: Run all tests
        run: bats --recursive tests/ || exit 1

  create-distribution:
    needs: [quick-checks, full-tests]
    runs-on: ubuntu-latest
    timeout-minutes: 20
    permissions:
      contents: write  # Required to upload release assets
      id-token: write  # Required for some GitHub API operations
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.release.tag_name }}
      
      - name: Get version from tag
        id: get_version
        run: |
          # Use github.event.release.tag_name for release events (not GITHUB_REF)
          TAG_NAME="${{ github.event.release.tag_name }}"
          
          if [[ "${TAG_NAME}" =~ ^v(.+)$ ]]; then
            VERSION="${BASH_REMATCH[1]}"
          elif [[ "${TAG_NAME}" =~ ^(.+)$ ]]; then
            VERSION="${TAG_NAME}"
          else
            echo "Error: Tag format not recognized. Expected 'v*' or '*'."
            exit 1
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "package_name=dev-infra-${VERSION}" >> $GITHUB_OUTPUT
      
      - name: Merge release changelog to root changelog
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          RELEASE_CHANGELOG="admin/planning/releases/v${VERSION}/CHANGELOG.md"
          
          # Check if release-specific changelog exists
          if [ -f "$RELEASE_CHANGELOG" ]; then
            echo "Found release changelog at $RELEASE_CHANGELOG, merging into root CHANGELOG.md..."
            
            # Extract the version section from release changelog
            # The release changelog should start with "## [X.Y.Z]" and end before next "##" or EOF
            # Use awk to extract from the version header to the next header or end of file
            awk "/^## \[${VERSION}\]/,/^## \[/ { if (/^## \[/ && !/^## \[${VERSION}\]/) exit; print }" "$RELEASE_CHANGELOG" >> CHANGELOG.md
            
            echo "✅ Release changelog merged into root CHANGELOG.md"
          else
            echo "ℹ️  No release changelog found at $RELEASE_CHANGELOG, skipping merge"
            echo "ℹ️  Note: Root CHANGELOG.md should already have the version section if release changelog doesn't exist"
          fi
      
      - name: Merge admin changelog to root changelog
        run: |
          # Note: This intentionally includes admin/internal changes in the distribution.
          # The admin changelog provides transparency about internal development decisions
          # and processes, which can be valuable for users understanding the project.
          if [ -f "admin/CHANGELOG.md" ]; then
            echo "Found admin/CHANGELOG.md, merging into root CHANGELOG.md..."
            
            # Append admin changelog content to root changelog with clear section header
            echo "" >> CHANGELOG.md
            echo "---" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "## Internal/Admin Changes" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            echo "*Note: This section documents internal development decisions and processes.*" >> CHANGELOG.md
            echo "" >> CHANGELOG.md
            cat admin/CHANGELOG.md >> CHANGELOG.md
            
            echo "✅ Admin changelog merged into root CHANGELOG.md"
          else
            echo "ℹ️  No admin/CHANGELOG.md found, skipping merge"
          fi
      
      - name: Create distribution package
        run: |
          PACKAGE_NAME="${{ steps.get_version.outputs.package_name }}"
          mkdir -p "${PACKAGE_NAME}"
          
          # Copy user-facing files
          cp -r templates/ "${PACKAGE_NAME}/templates/"
          cp -r scripts/ "${PACKAGE_NAME}/scripts/"
          cp -r docs/ "${PACKAGE_NAME}/docs/"
          cp README.md "${PACKAGE_NAME}/"
          cp CHANGELOG.md "${PACKAGE_NAME}/"
          cp CONTRIBUTING.md "${PACKAGE_NAME}/"
          [ -f LICENSE ] && cp LICENSE "${PACKAGE_NAME}/"
          
          # Create tarball
          tar -czf "${PACKAGE_NAME}.tar.gz" "${PACKAGE_NAME}/"
          
          # Create zip for Windows users
          zip -r "${PACKAGE_NAME}.zip" "${PACKAGE_NAME}/"
          
          echo "✅ Distribution packages created"
          ls -lh *.tar.gz *.zip
      
      - name: Create command bundle
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          COMMANDS_PACKAGE="commands-v${VERSION}"
          
          echo "Creating command bundle..."
          
          # Create commands directory structure
          mkdir -p "${COMMANDS_PACKAGE}/commands"
          
          # Copy command files from standard-project template
          cp templates/standard-project/.cursor/commands/*.md "${COMMANDS_PACKAGE}/commands/"
          
          # Create VERSION file for metadata
          echo "VERSION=${VERSION}" > "${COMMANDS_PACKAGE}/commands/VERSION"
          echo "DATE=$(date -u +%Y-%m-%d)" >> "${COMMANDS_PACKAGE}/commands/VERSION"
          echo "COMMANDS=$(ls -1 ${COMMANDS_PACKAGE}/commands/*.md | wc -l)" >> "${COMMANDS_PACKAGE}/commands/VERSION"
          
          # Create tarball (archive contains commands/ directory at root)
          tar -czf "${COMMANDS_PACKAGE}.tar.gz" -C "${COMMANDS_PACKAGE}" commands/
          
          echo "✅ Command bundle created"
          ls -lh "${COMMANDS_PACKAGE}.tar.gz"
          
          # Show bundle contents
          echo "Bundle contents:"
          tar -tzf "${COMMANDS_PACKAGE}.tar.gz"

      - name: Validate command bundle
        run: |
          VERSION="${{ steps.get_version.outputs.version }}"
          COMMANDS_PACKAGE="commands-v${VERSION}"
          
          echo "Validating command bundle..."
          
          # Extract to test
          TEST_DIR="/tmp/test-commands"
          mkdir -p "${TEST_DIR}"
          tar -xzf "${COMMANDS_PACKAGE}.tar.gz" -C "${TEST_DIR}"
          
          # Check commands directory exists
          echo "Checking commands directory..."
          [ -d "${TEST_DIR}/commands" ] || { echo "❌ Missing commands/"; exit 1; }
          
          # Check VERSION file exists
          echo "Checking VERSION file..."
          [ -f "${TEST_DIR}/commands/VERSION" ] || { echo "❌ Missing VERSION file"; exit 1; }
          cat "${TEST_DIR}/commands/VERSION"
          
          # Check key commands exist
          echo "Checking key command files..."
          for cmd in pr.md task-phase.md reflect.md explore.md decision.md research.md; do
            [ -f "${TEST_DIR}/commands/${cmd}" ] || { echo "❌ Missing ${cmd}"; exit 1; }
          done
          
          # Count commands (should be 19+)
          CMD_COUNT=$(ls -1 "${TEST_DIR}/commands/"*.md 2>/dev/null | wc -l)
          echo "Found ${CMD_COUNT} command files"
          [ "$CMD_COUNT" -ge 19 ] || { echo "❌ Expected at least 19 commands, found ${CMD_COUNT}"; exit 1; }
          
          echo "✅ Command bundle validation passed"
          rm -rf "${TEST_DIR}"

      - name: Validate distribution package
        run: |
          PACKAGE_NAME="${{ steps.get_version.outputs.package_name }}"
          
          echo "Validating distribution package..."
          
          # Extract tarball to test
          TEST_DIR="/tmp/test-dist"
          mkdir -p "${TEST_DIR}"
          tar -xzf "${PACKAGE_NAME}.tar.gz" -C "${TEST_DIR}"
          
          # Check required files exist
          echo "Checking required files..."
          [ -d "${TEST_DIR}/${PACKAGE_NAME}/templates" ] || { echo "❌ Missing templates/"; exit 1; }
          [ -d "${TEST_DIR}/${PACKAGE_NAME}/scripts" ] || { echo "❌ Missing scripts/"; exit 1; }
          [ -d "${TEST_DIR}/${PACKAGE_NAME}/docs" ] || { echo "❌ Missing docs/"; exit 1; }
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/README.md" ] || { echo "❌ Missing README.md"; exit 1; }
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/CHANGELOG.md" ] || { echo "❌ Missing CHANGELOG.md"; exit 1; }
          
          # Check internal files are excluded
          echo "Checking internal files are excluded..."
          [ ! -d "${TEST_DIR}/${PACKAGE_NAME}/admin" ] || { echo "❌ admin/ should not be in distribution"; exit 1; }
          [ ! -d "${TEST_DIR}/${PACKAGE_NAME}/.cursor" ] || { echo "❌ .cursor/ should not be in distribution"; exit 1; }
          [ ! -d "${TEST_DIR}/${PACKAGE_NAME}/.github" ] || { echo "❌ .github/ should not be in distribution"; exit 1; }
          [ ! -f "${TEST_DIR}/${PACKAGE_NAME}/start.txt" ] || { echo "❌ start.txt should not be in distribution"; exit 1; }
          
          # Test that scripts are present
          echo "Checking scripts are present..."
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/scripts/new-project.sh" ] || { echo "❌ Missing new-project.sh"; exit 1; }
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/scripts/validate-templates.sh" ] || { echo "❌ Missing validate-templates.sh"; exit 1; }
          
          # Test that both templates exist
          echo "Checking templates..."
          [ -d "${TEST_DIR}/${PACKAGE_NAME}/templates/standard-project" ] || { echo "❌ Missing standard-project template"; exit 1; }
          [ -d "${TEST_DIR}/${PACKAGE_NAME}/templates/learning-project" ] || { echo "❌ Missing learning-project template"; exit 1; }
          
          # Test that documentation exists
          echo "Checking documentation..."
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/docs/README.md" ] || { echo "❌ Missing docs/README.md"; exit 1; }
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/docs/TEMPLATE-USAGE.md" ] || { echo "❌ Missing TEMPLATE-USAGE.md"; exit 1; }
          [ -f "${TEST_DIR}/${PACKAGE_NAME}/docs/INTEGRATION.md" ] || { echo "❌ Missing INTEGRATION.md"; exit 1; }
          
          echo "✅ Distribution package validation passed"
          
          # Cleanup
          rm -rf "${TEST_DIR}"
      
      - name: Generate checksums
        run: |
          PACKAGE_NAME="${{ steps.get_version.outputs.package_name }}"
          VERSION="${{ steps.get_version.outputs.version }}"
          
          echo "Generating checksums..."
          sha256sum "${PACKAGE_NAME}.tar.gz" > "${PACKAGE_NAME}.tar.gz.sha256"
          sha256sum "${PACKAGE_NAME}.zip" > "${PACKAGE_NAME}.zip.sha256"
          sha256sum "commands-v${VERSION}.tar.gz" > "commands-v${VERSION}.tar.gz.sha256"
          
          echo "✅ Checksums generated"
          cat "${PACKAGE_NAME}.tar.gz.sha256"
          cat "${PACKAGE_NAME}.zip.sha256"
          cat "commands-v${VERSION}.tar.gz.sha256"
      
      - name: Upload distribution to release
        run: |
          PACKAGE_NAME="dev-infra-${{ steps.get_version.outputs.version }}"
          VERSION="${{ steps.get_version.outputs.version }}"
          TAG_NAME="${{ github.event.release.tag_name }}"
          
          # Upload each file using GitHub CLI
          # Includes main distribution packages and command bundle
          # Note: Uses PAT_TOKEN if available for manually-created releases
          gh release upload "$TAG_NAME" \
            "${PACKAGE_NAME}.tar.gz" \
            "${PACKAGE_NAME}.tar.gz.sha256" \
            "${PACKAGE_NAME}.zip" \
            "${PACKAGE_NAME}.zip.sha256" \
            "commands-v${VERSION}.tar.gz" \
            "commands-v${VERSION}.tar.gz.sha256" \
            --clobber \
            --repo "${{ github.repository }}"
        env:
          GITHUB_TOKEN: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
